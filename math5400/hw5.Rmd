---
title: "MATH540-HW5"
author: "Ron Coursera"
date: "Monday, March 30, 2015"
output: html_document
---

###Problem 1.a  

Show that the function f(x)=tan(x)-2x has a root *r* with *0 < r < pi/2* (Hint: sketch a graph)

```{r}
x=seq(0.01,3.14,by=0.01)
fx=tan(x) - 2*x
plot(x,fx,type='l',col='red',ylim=c(-10,10))
abline(v=pi/2,lwd=4,col='gray')
abline(h=0)
points(1.165,0,pch=1,cex=3)

```

###Problem 1.b  

Use a calculator or computer and the bisection method to find the root to some reasonable accuracy.  

Note: From the previous graph, it is observed that the sign of f(0+e) is the same as the sign of f(pi-epsilon). In order to start the bisection method, we need endpoints of differing sign, so we start the search over the range of (0,pi/2)

```{r}
n=0
epsilon=.000001
delta=.00001
a=0.0+epsilon
b=pi/2-epsilon
x=seq(a,b,by=epsilon)
fx=tan(x) - 2*x
while (n<100 & (b-a)>delta) {
  n = n+1
  if ( fx[1]/abs(fx[1]) == fx[round(length(fx)/2)]/abs(fx[round(length(fx)/2)]) ) {
    a=x[round(length(x)/2)]
    b=b
  } else {
    a=a
    b=x[round(length(x)/2)]
  }
  x=seq(a,b,by=epsilon)
  fx=tan(x) - 2*x
}
sprintf("The number of iteration is: %d",n)
sprintf("The interval length is:  %f",(b-a))
sprintf("The approximate root is at:  %f",(b+a)/2)
sprintf("Which evaluates as:  %f",tan((b+a)/2) - 2*(b+a)/2)
```

###Problem 1.c

Use a calculator or computer and  Netwon's method to find the root to some reasonable accuracy.  

Note: In order to start the Newton's method, we need an initial point somewhere "near" the root. For this exercise, 1.0 is used as the intital point.

```{r, eval=FALSE}
f <- function(x) {
  return(tan(x) - 2*x)
}

epsilon=.0001
delta=.001
x0 = 1.0
f.x = f(x0)
n=0
while (n<20 & abs(f.x)>epsilon) {
  n=n+1
  df.dx = (f(x0+delta)-f(x0))/delta
  x1 = (x0 - (f(x0)/df.dx))
  x0 = x1
  f.x = f(x0)
}
sprintf("The number of iteration sis: %d",n)
sprintf("The approximate root is at: %f",x0)
sprintf("Which evaluates as: %f",f(x0))
```
```{r,echo=FALSE}
f <- function(x) {
  return(tan(x) - 2*x)
}

epsilon=.0001
delta=.001
x0 = 1.0
f.x = f(x0)
n=0
while (n<20 & abs(f.x)>epsilon) {
  n=n+1
  df.dx = (f(x0+delta)-f(x0))/delta
  x1 = (x0 - (f(x0)/df.dx))
  x0 = x1
  f.x = f(x0)
}
sprintf("The number of iterations is: %d",n)
sprintf("The approximate root is at: %f",x0)
sprintf("Which evaluates as: %f",f(x0))
```
However, even a small step away from the root can cause the algorithm to diverge. For x=pi/4, I obtain the following result.  

```{r, echo=FALSE}
f <- function(x) {
  return(tan(x) - 2*x)
}

epsilon=.0001
delta=.001
x0 = pi/4
f.x = f(x0)
n=0
while (n<20 & abs(f.x)>epsilon) {
  n=n+1
  df.dx = (f(x0+delta)-f(x0))/delta
  x1 = (x0 - (f(x0)/df.dx))
  x0 = x1
  f.x = f(x0)
}
sprintf("The number of iterations is: %d",n)
sprintf("The approximate root is at: %f",x0)
sprintf("Which evaluates as: %f",f(x0))
```

###Problem 2
Let A=[[2,1],[1,3]] and z=[1,2]  
Define f(X) = (X-Z) dot A(X-Z)  
Let X0 = [0,0], show that Netwon's method finds the minimizer of f in one step.  

http://nbviewer.ipython.org/urls/dl.dropboxusercontent.com/u/41832416/ipython%20notebooks/lab2.ipynb

```{r, eval=FALSE}
f <- function(X,A,Z) {
  return( t(X-Z)%*%(A%*%(X-Z)) )
}

grad <- function(x){
  return(t(t(c(4*x[1,1]+2*x[2,1]-8,6*x[2,1]+2*x[1,1]-14))))
}

hess <- function(x){
  return(rbind(c(4,2),c(2,6)))
}

vlen <- function(v) {
  return(sum(v^2)^0.5)
}

A=rbind(c(2,1),c(1,3))
Z=t(t(c(1,2)))
x0=t(t(c(0,0)))

epsilon=.0001
delta=t(t(c(.001,.001)))
f.x = f(x0,A,Z)
n=0
while (n<20 & vlen(f.x)>epsilon) {
  n=n+1
  x1 = x0-solve(hess(x0))%*%grad(x0)
  x0 = x1
  f.x = f(x0,A,Z)
  print(vlen(f.x))
}
```

```{r, echo=FALSE}
f <- function(X,A,Z) {
  return( t(X-Z)%*%(A%*%(X-Z)) )
}

grad <- function(x){
  return(t(t(c(4*x[1,1]+2*x[2,1]-8,6*x[2,1]+2*x[1,1]-14))))
}

hess <- function(x){
  return(rbind(c(4,2),c(2,6)))
}

vlen <- function(v) {
  return(sum(v^2)^0.5)
}

A=rbind(c(2,1),c(1,3))
Z=t(t(c(1,2)))
x0=t(t(c(0,0)))

epsilon=.0001
delta=t(t(c(.001,.001)))
f.x = f(x0,A,Z)
n=0
while (n<20 & vlen(f.x)>epsilon) {
  n=n+1
  x1 = x0-solve(hess(x0))%*%grad(x0)
  x0 = x1
  f.x = f(x0,A,Z)
  print(vlen(f.x))
}
sprintf("The number of iterations is: %d",n)
print("The approximate root is at:")
print(x0)
print("Which evaluates as: ")
print(f.x)
```

###Problem 3

Attack problem two with steepest descent method. Start at X0, use two iterations.

```{r}
f <- function(X,A,Z) {
  return( t(X-Z)%*%(A%*%(X-Z)) )
}

grad <- function(x){
  return(t(t(c(4*x[1,1]+2*x[2,1]-8,6*x[2,1]+2*x[1,1]-14))))
}

A=rbind(c(2,1),c(1,3))
Z=t(t(c(1,2)))
x0=t(t(c(0,0)))
f.x = f(x0,A,Z)

x1=x0
alpha=0.5
for (i in 1:20) {
  x1 <- x1 - alpha * grad(x1)   
}
x1
```

###Problem 4

Attack problem two with Gauss-Seidel method. Start at X0, go through 4 steps, two for each of the two coordinate directions.

Note: This solution solves both coordinates simultaneously.

```{r}
# 2x2
LT <- function (A) {
  A[1,2]=0
  return(A)
}
UT <- function (A) {
  A[1,1]=0
  A[2,1]=0
  A[2,2]=0
  return(A)
}

A=rbind(c(2,1),c(1,3))
Z=t(t(c(1,2)))
x0=t(t(c(0,0)))
b=x0-Z
T=-1*solve(LT(A))%*%UT(A)
C=solve(LT(A))%*%b

x=x0
print(x)
for (i in 1:20) {
  x=T%*%x + C
  print(x)
}

```